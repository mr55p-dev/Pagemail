// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package dbqueries

import (
	"context"
	"database/sql"
	"time"
)

const createPage = `-- name: CreatePage :exec
INSERT INTO pages (id, user_id, url, created, updated)
VALUES (?, ?, ?, ?, ?)
`

type CreatePageParams struct {
	ID      string
	UserID  string
	Url     string
	Created time.Time
	Updated time.Time
}

func (q *Queries) CreatePage(ctx context.Context, arg CreatePageParams) error {
	_, err := q.db.ExecContext(ctx, createPage,
		arg.ID,
		arg.UserID,
		arg.Url,
		arg.Created,
		arg.Updated,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (
	id, username, email, password,
	avatar, subscribed, shortcut_token,
	has_readability, created, updated
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	ID             string
	Username       string
	Email          string
	Password       []byte
	Avatar         sql.NullString
	Subscribed     bool
	ShortcutToken  string
	HasReadability bool
	Created        time.Time
	Updated        time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Avatar,
		arg.Subscribed,
		arg.ShortcutToken,
		arg.HasReadability,
		arg.Created,
		arg.Updated,
	)
	return err
}

const deletePageById = `-- name: DeletePageById :execrows
DELETE FROM pages 
WHERE id = ?
`

func (q *Queries) DeletePageById(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePageById, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deletePagesByUserId = `-- name: DeletePagesByUserId :execrows
DELETE FROM pages 
WHERE user_id = ?
`

func (q *Queries) DeletePagesByUserId(ctx context.Context, userID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePagesByUserId, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const readPageById = `-- name: ReadPageById :one
SELECT id, user_id, url, title, description, image_url, readability_status, readability_task_data, is_readable, created, updated FROM pages
WHERE id = ?
LIMIT 1
`

func (q *Queries) ReadPageById(ctx context.Context, id string) (Page, error) {
	row := q.db.QueryRowContext(ctx, readPageById, id)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.ImageUrl,
		&i.ReadabilityStatus,
		&i.ReadabilityTaskData,
		&i.IsReadable,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const readPagesByUserBetween = `-- name: ReadPagesByUserBetween :many
SELECT id, user_id, url, title, description, image_url, readability_status, readability_task_data, is_readable, created, updated FROM pages 
WHERE created BETWEEN ?2 AND ?3
AND user_id = ?
`

type ReadPagesByUserBetweenParams struct {
	Start  time.Time
	End    time.Time
	UserID string
}

func (q *Queries) ReadPagesByUserBetween(ctx context.Context, arg ReadPagesByUserBetweenParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, readPagesByUserBetween, arg.Start, arg.End, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.ReadabilityStatus,
			&i.ReadabilityTaskData,
			&i.IsReadable,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readPagesByUserId = `-- name: ReadPagesByUserId :many
SELECT id, user_id, url, title, description, image_url, readability_status, readability_task_data, is_readable, created, updated FROM pages
WHERE user_id = ?
ORDER BY created DESC
`

func (q *Queries) ReadPagesByUserId(ctx context.Context, userID string) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, readPagesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.ReadabilityStatus,
			&i.ReadabilityTaskData,
			&i.IsReadable,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readUserByEmail = `-- name: ReadUserByEmail :one
SELECT id, username, email, password, avatar, subscribed, shortcut_token, has_readability, created, updated FROM users 
WHERE email = ?
LIMIT 1
`

func (q *Queries) ReadUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, readUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Avatar,
		&i.Subscribed,
		&i.ShortcutToken,
		&i.HasReadability,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const readUserById = `-- name: ReadUserById :one
SELECT id, username, email, password, avatar, subscribed, shortcut_token, has_readability, created, updated FROM users 
WHERE id = ? 
LIMIT 1
`

func (q *Queries) ReadUserById(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, readUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Avatar,
		&i.Subscribed,
		&i.ShortcutToken,
		&i.HasReadability,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const readUserByShortcutToken = `-- name: ReadUserByShortcutToken :one
SELECT id, username, email, password, avatar, subscribed, shortcut_token, has_readability, created, updated FROM users 
WHERE shortcut_token = ?
LIMIT 1
`

func (q *Queries) ReadUserByShortcutToken(ctx context.Context, shortcutToken string) (User, error) {
	row := q.db.QueryRowContext(ctx, readUserByShortcutToken, shortcutToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Avatar,
		&i.Subscribed,
		&i.ShortcutToken,
		&i.HasReadability,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const readUserShortcutTokens = `-- name: ReadUserShortcutTokens :many
SELECT id, shortcut_token FROM users 
WHERE shortcut_token IS NOT NULL
`

type ReadUserShortcutTokensRow struct {
	ID            string
	ShortcutToken string
}

func (q *Queries) ReadUserShortcutTokens(ctx context.Context) ([]ReadUserShortcutTokensRow, error) {
	rows, err := q.db.QueryContext(ctx, readUserShortcutTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadUserShortcutTokensRow
	for rows.Next() {
		var i ReadUserShortcutTokensRow
		if err := rows.Scan(&i.ID, &i.ShortcutToken); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readUsersWithMail = `-- name: ReadUsersWithMail :many
SELECT id, username, email, password, avatar, subscribed, shortcut_token, has_readability, created, updated FROM users 
WHERE subscribed = true
`

func (q *Queries) ReadUsersWithMail(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, readUsersWithMail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.Avatar,
			&i.Subscribed,
			&i.ShortcutToken,
			&i.HasReadability,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET
	username = ?,
	password = ?,
	avatar = ?,
	subscribed = ?,
	shortcut_token = ?,
	has_readability = ?,
	updated = ?
WHERE id = ?
`

type UpdateUserParams struct {
	Username       string
	Password       []byte
	Avatar         sql.NullString
	Subscribed     bool
	ShortcutToken  string
	HasReadability bool
	Updated        time.Time
	ID             string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Username,
		arg.Password,
		arg.Avatar,
		arg.Subscribed,
		arg.ShortcutToken,
		arg.HasReadability,
		arg.Updated,
		arg.ID,
	)
	return err
}

const updateUserShortcutToken = `-- name: UpdateUserShortcutToken :exec
UPDATE users SET 
shortcut_token = ? 
WHERE id = ?
`

type UpdateUserShortcutTokenParams struct {
	ShortcutToken string
	ID            string
}

func (q *Queries) UpdateUserShortcutToken(ctx context.Context, arg UpdateUserShortcutTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateUserShortcutToken, arg.ShortcutToken, arg.ID)
	return err
}

const updateUserSubscription = `-- name: UpdateUserSubscription :exec
UPDATE users SET 
subscribed = ? 
WHERE id = ?
`

type UpdateUserSubscriptionParams struct {
	Subscribed bool
	ID         string
}

func (q *Queries) UpdateUserSubscription(ctx context.Context, arg UpdateUserSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSubscription, arg.Subscribed, arg.ID)
	return err
}

const upsertPage = `-- name: UpsertPage :exec

INSERT OR REPLACE INTO pages (
	id, user_id, url, title, description,
	image_url, readability_status, readability_task_data,
	is_readable, created, updated
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type UpsertPageParams struct {
	ID                  string
	UserID              string
	Url                 string
	Title               sql.NullString
	Description         sql.NullString
	ImageUrl            sql.NullString
	ReadabilityStatus   sql.NullString
	ReadabilityTaskData sql.NullString
	IsReadable          sql.NullBool
	Created             time.Time
	Updated             time.Time
}

// ORDER BY created DESC;
func (q *Queries) UpsertPage(ctx context.Context, arg UpsertPageParams) error {
	_, err := q.db.ExecContext(ctx, upsertPage,
		arg.ID,
		arg.UserID,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.ImageUrl,
		arg.ReadabilityStatus,
		arg.ReadabilityTaskData,
		arg.IsReadable,
		arg.Created,
		arg.Updated,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.auth.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createIdpAuth = `-- name: CreateIdpAuth :exec
INSERT INTO auth (
    user_id,
    platform,
    credential
) VALUES ($1, $2, crypt($3, gen_salt('bf')))
`

type CreateIdpAuthParams struct {
	UserID   uuid.UUID
	Platform string
	Crypt    string
}

func (q *Queries) CreateIdpAuth(ctx context.Context, arg CreateIdpAuthParams) error {
	_, err := q.db.Exec(ctx, createIdpAuth, arg.UserID, arg.Platform, arg.Crypt)
	return err
}

const createLocalAuth = `-- name: CreateLocalAuth :exec
INSERT INTO auth (
    user_id,
    platform,
	credential
) VALUES ($1, 'pagemail', crypt($2, gen_salt('bf')))
`

type CreateLocalAuthParams struct {
	UserID uuid.UUID
	Crypt  string
}

func (q *Queries) CreateLocalAuth(ctx context.Context, arg CreateLocalAuthParams) error {
	_, err := q.db.Exec(ctx, createLocalAuth, arg.UserID, arg.Crypt)
	return err
}

const createShortcutAuth = `-- name: CreateShortcutAuth :exec
INSERT INTO auth (
    user_id,
    platform,
    credential
) VALUES ($1, 'shortcut', crypt($2, gen_salt('bf')))
`

type CreateShortcutAuthParams struct {
	UserID uuid.UUID
	Crypt  string
}

func (q *Queries) CreateShortcutAuth(ctx context.Context, arg CreateShortcutAuthParams) error {
	_, err := q.db.Exec(ctx, createShortcutAuth, arg.UserID, arg.Crypt)
	return err
}

const readAuthMethods = `-- name: ReadAuthMethods :many
SELECT id, user_id, platform, credential, reset_token, reset_expiry, created, updated FROM auth WHERE user_id = $1
`

func (q *Queries) ReadAuthMethods(ctx context.Context, userID uuid.UUID) ([]Auth, error) {
	rows, err := q.db.Query(ctx, readAuthMethods, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Auth
	for rows.Next() {
		var i Auth
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Platform,
			&i.Credential,
			&i.ResetToken,
			&i.ResetExpiry,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readByResetToken = `-- name: ReadByResetToken :one
SELECT user_id
FROM auth
WHERE reset_token = $1
    AND reset_expiry > $2
LIMIT 1
`

type ReadByResetTokenParams struct {
	ResetToken  pgtype.Text
	ResetExpiry pgtype.Timestamp
}

func (q *Queries) ReadByResetToken(ctx context.Context, arg ReadByResetTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, readByResetToken, arg.ResetToken, arg.ResetExpiry)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const readByUidPlatform = `-- name: ReadByUidPlatform :one
SELECT id, user_id, platform, credential, reset_token, reset_expiry, created, updated
FROM auth
WHERE user_id = $1
AND platform = $2
LIMIT 1
`

type ReadByUidPlatformParams struct {
	UserID   uuid.UUID
	Platform string
}

func (q *Queries) ReadByUidPlatform(ctx context.Context, arg ReadByUidPlatformParams) (Auth, error) {
	row := q.db.QueryRow(ctx, readByUidPlatform, arg.UserID, arg.Platform)
	var i Auth
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Platform,
		&i.Credential,
		&i.ResetToken,
		&i.ResetExpiry,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const readUserByShortcut = `-- name: ReadUserByShortcut :one
SELECT users.id, users.email, users.username, users.has_readability, users.created, users.updated
FROM users
LEFT JOIN auth
    ON auth.user_id = users.id
    AND auth.platform = 'shortcut'
WHERE auth.credential = $1
LIMIT 1
`

func (q *Queries) ReadUserByShortcut(ctx context.Context, credential string) (User, error) {
	row := q.db.QueryRow(ctx, readUserByShortcut, credential)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.HasReadability,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :execrows
UPDATE auth
SET credential = $1
WHERE user_id = $2
    AND platform = 'pagemail'
`

type UpdatePasswordParams struct {
	Credential string
	UserID     uuid.UUID
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (int64, error) {
	result, err := q.db.Exec(ctx, updatePassword, arg.Credential, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateResetToken = `-- name: UpdateResetToken :exec
UPDATE auth
SET 
    reset_token = $1,
    reset_expiry = $2
WHERE user_id = $3
    AND platform = 'pagemail'
`

type UpdateResetTokenParams struct {
	ResetToken  pgtype.Text
	ResetExpiry pgtype.Timestamp
	UserID      uuid.UUID
}

func (q *Queries) UpdateResetToken(ctx context.Context, arg UpdateResetTokenParams) error {
	_, err := q.db.Exec(ctx, updateResetToken, arg.ResetToken, arg.ResetExpiry, arg.UserID)
	return err
}

const updateShortcutToken = `-- name: UpdateShortcutToken :exec
UPDATE auth
SET credential = $1
WHERE user_id = $2
    AND platform = 'shortcut'
`

type UpdateShortcutTokenParams struct {
	Credential string
	UserID     uuid.UUID
}

func (q *Queries) UpdateShortcutToken(ctx context.Context, arg UpdateShortcutTokenParams) error {
	_, err := q.db.Exec(ctx, updateShortcutToken, arg.Credential, arg.UserID)
	return err
}
